# https://registry.khronos.org/SPIR-V/specs/unified1/MachineReadableGrammar.html

import sys
import json


def sanitize(identifier: str) -> str:
    if identifier[0].isdigit() or identifier == "None":
        return "_" + identifier
    return identifier


def main() -> None:
    """
    Convert spirv grammar json to Python file the way we like it.
    """
    fn = sys.argv[1]
    with open(fn, "rb") as f:
        data = json.load(f)

    _copyright = data.pop("copyright")
    major = data.pop("major_version")
    minor = data.pop("minor_version")
    revision = data.pop("revision")
    magic = data.pop("magic_number")
    _instruction_printing_class = data.pop("instruction_printing_class")
    instructions = data.pop("instructions")
    operand_kinds = data.pop("operand_kinds")
    assert len(data) == 0, data.keys()

    print(
        f"# automatically generated by vutur/tools/spriv_generator.py from {fn} version {major}.{minor}.{revision}"
    )

    print("from enum import IntFlag, Enum")
    print("from typing import Tuple, Optional")
    print("from dataclasses import dataclass")
    print()

    print(f"SPIRV_MAGIC_NUMBER = {magic}")
    print()
    print("@dataclass")
    print("class SpirvInstruction:")
    print("    opcode: int")
    print("    args: list[object]")
    print("    result: object")
    print()
    print()

    kind_types = {}
    for operand_kind in operand_kinds:
        category = operand_kind.pop("category")
        kind = operand_kind.pop("kind")
        enumerants = operand_kind.pop("enumerants", None)
        match category:
            case "BitEnum":
                print(f"class {kind}(IntFlag):")
                for enumerant in enumerants:
                    enumerant_ = enumerant.pop("enumerant")
                    value = enumerant.pop("value")
                    _version = enumerant.pop("version", None)
                    _parameters = enumerant.pop("parameters", [])
                    _capabilities = enumerant.pop("capabilities", [])
                    _extensions = enumerant.pop("extensions", [])
                    assert len(enumerant) == 0, enumerant.keys()

                    if enumerant_ == "None":
                        assert value == "0x0000", value
                        continue

                    print(f"    {sanitize(enumerant_)} = {value}")
                print()
                kind_types[kind] = kind
            case "ValueEnum":
                print(f"class {kind}(Enum):")
                for enumerant in enumerants:
                    enumerant_ = enumerant.pop("enumerant")
                    value = enumerant.pop("value")
                    print(f"    {sanitize(enumerant_)} = {value}")
                print()
                kind_types[kind] = kind
            case "Id":
                _doc = operand_kind.pop("doc")
                # we don't differentiate between id's for now
                kind_types[kind] = "SpirvInstruction"
            case "Literal":
                _doc = operand_kind.pop("doc")
                match kind:
                    case (
                        "LiteralInteger"
                        | "LiteralExtInstInteger"
                        | "LiteralSpecConstantOpInteger"
                    ):
                        t = "int"
                    case "LiteralString":
                        t = "str"
                    case "LiteralFloat" | "LiteralContextDependentNumber":
                        t = "float"
                    case e:
                        assert False, e
                kind_types[kind] = t
            case "Composite":
                bases = operand_kind.pop("bases")
                ts = [kind_types[k] for k in bases]
                t = f"Tuple[{",".join(ts)}]"
                kind_types[kind] = t
            case e:
                assert False, e
        # for enumerant in enumerants:
        #     assert len(enumerant) == 0, enumerant.keys()

        assert len(operand_kind) == 0, operand_kind.keys()

    for instruction in instructions:
        opname = instruction.pop("opname")
        _class = instruction.pop("class")
        opcode = instruction.pop("opcode")
        _version = instruction.pop("version")
        _lastversion = instruction.pop("lastVersion", None)
        operands = instruction.pop("operands", [])
        _capabilities = instruction.pop("capabilities", [])
        _extensions = instruction.pop("extensions", [])
        assert len(instruction) == 0, instruction.keys()

        print(f"def {opname}(")
        varnames = [
            "foo",
            "bar",
            "baz",
            "qux",
            "quux",
            "quuux",
            "quuuux",
            "quuuuux",
            "quuuuuux",
            "quuuuuuux",
            "quuuuuuuux",
            "quuuuuuuuux",
            "quuuuuuuuuux",
            "quuuuuuuuuuux",
        ]
        usednames = []
        result = None
        for operand in operands:
            kind = operand.pop("kind")
            quantifier = operand.pop("quantifier", None)
            name = operand.pop("name", None)
            match kind:
                case "IdResultType":
                    varname = "rtype"
                case "IdResult":
                    result = kind_types[kind]
                    continue
                case _:
                    varname = varnames.pop(0)
                    usednames.append(varname)
            assert len(operand) == 0, operand.keys()
            t = kind_types[kind]
            comment = ""
            if name is not None:
                comment = f" # {" ".join(name.splitlines())}"
            match quantifier:
                case None:
                    print(f"    {varname}:{t},{comment}")
                case "?":
                    print(f"    {varname}: Optional[{t}] =None ,{comment}")
                case "*":
                    print(f"    *{varname}:{t},{comment}")
        print(") -> SpirvInstruction:")
        print("    return SpirvInstruction(")
        print(f"        {opcode=},")
        print(f"        args=[{",".join(usednames)}],")
        print(f"        {result=},")
        print("    )")
        print()


if __name__ == "__main__":
    main()
