# https://registry.khronos.org/SPIR-V/specs/unified1/MachineReadableGrammar.html

import sys
import json


def sanitize(identifier: str) -> str:
    if identifier[0].isdigit() or identifier == "None":
        return "_" + identifier
    return identifier


def main() -> None:
    """
    Convert spirv grammar json to Python file the way we like it.
    """
    fn = sys.argv[1]
    with open(fn, "rb") as f:
        data = json.load(f)

    _copyright = data.pop("copyright")
    major = data.pop("major_version")
    minor = data.pop("minor_version")
    revision = data.pop("revision")
    magic = data.pop("magic_number")
    _instruction_printing_class = data.pop("instruction_printing_class")
    instructions = data.pop("instructions")
    operand_kinds = data.pop("operand_kinds")
    assert len(data) == 0, data.keys()

    print('"""')
    print(
        f"automatically generated by vutur/tools/spirv_generator.py from {fn} version {major}.{minor}.{revision}"
    )
    print('"""')

    print("from enum import IntFlag, IntEnum")
    print("from typing import Optional, Union")
    print("from dataclasses import dataclass")
    print()
    print()
    print(f"SPIRV_MAGIC_NUMBER = {magic}")
    print()
    print()
    print('base_argtype = Union[None, "SpirvInstruction", str, int, float]')
    print('argtype = Union[tuple["argtype", ...], base_argtype]')
    print()
    print()
    print("@dataclass")
    print("class SpirvInstruction:")
    print("    opcode: int")
    print("    args: list[argtype]")
    print("    hasresult: object")

    kind_types = {}
    for operand_kind in operand_kinds:
        category = operand_kind.pop("category")
        kind = operand_kind.pop("kind")
        enumerants = operand_kind.pop("enumerants", None)
        match category:
            case "BitEnum":
                print()
                print()
                print(f"class {kind}(IntFlag):")
                for enumerant in enumerants:
                    enumerant_ = enumerant.pop("enumerant")
                    value = enumerant.pop("value")
                    _version = enumerant.pop("version", None)
                    _parameters = enumerant.pop("parameters", [])
                    _capabilities = enumerant.pop("capabilities", [])
                    _extensions = enumerant.pop("extensions", [])
                    assert len(enumerant) == 0, enumerant.keys()

                    if enumerant_ == "None":
                        assert value == "0x0000", value
                        continue

                    print(f"    {sanitize(enumerant_)} = {value}")
                kind_types[kind] = kind
            case "ValueEnum":
                print()
                print()
                print(f"class {kind}(IntEnum):")
                for enumerant in enumerants:
                    enumerant_ = enumerant.pop("enumerant")
                    value = enumerant.pop("value")
                    print(f"    {sanitize(enumerant_)} = {value}")
                kind_types[kind] = kind
            case "Id":
                _doc = operand_kind.pop("doc")
                # we don't differentiate between id's for now
                kind_types[kind] = "SpirvInstruction"
            case "Literal":
                _doc = operand_kind.pop("doc")
                match kind:
                    case (
                        "LiteralInteger"
                        | "LiteralExtInstInteger"
                        | "LiteralSpecConstantOpInteger"
                    ):
                        t = "int"
                    case "LiteralString":
                        t = "str"
                    case "LiteralFloat" | "LiteralContextDependentNumber":
                        t = "float"
                    case e:
                        assert False, e
                kind_types[kind] = t
            case "Composite":
                bases = operand_kind.pop("bases")
                ts = [kind_types[k] for k in bases]
                t = f"tuple[{", ".join(ts)}]"
                kind_types[kind] = t
            case e:
                assert False, e
        # for enumerant in enumerants:
        #     assert len(enumerant) == 0, enumerant.keys()

        assert len(operand_kind) == 0, operand_kind.keys()

    for instruction in instructions:
        opname = instruction.pop("opname")
        _class = instruction.pop("class")
        opcode = instruction.pop("opcode")
        _version = instruction.pop("version")
        _lastversion = instruction.pop("lastVersion", None)
        operands = instruction.pop("operands", [])
        _capabilities = instruction.pop("capabilities", [])
        _extensions = instruction.pop("extensions", [])
        assert len(instruction) == 0, instruction.keys()

        usednames = []
        varnames = [
            "x",
            "y",
            "z",
            "a",
            "b",
            "c",
            "d",
            "e",
            "f",
            "g",
            "h",
            "i",
            "j",
            "k",
        ]
        hasresult = False
        for i in range(len(operands)):
            if operands[i]["kind"] == "OpResult":
                hasresult = True
                del operands[i]
        print()
        print()
        if len(operands) == 0:
            print(f"def {opname}() -> SpirvInstruction:")
        else:
            print(f"def {opname}(")
            for operand in operands:
                kind = operand.pop("kind")
                quantifier = operand.pop("quantifier", None)
                name = operand.pop("name", None)
                match kind:
                    case "IdResultType":
                        varname = "rtype"
                    case _:
                        varname = varnames.pop(0)
                        usednames.append(varname)
                assert len(operand) == 0, operand.keys()
                t = kind_types[kind]
                comment = ""
                if name is not None:
                    comment = f"  # {" ".join(name.splitlines())}"
                match quantifier:
                    case None:
                        print(f"    {varname}: {t},{comment}")
                    case "?":
                        print(f"    {varname}: Optional[{t}] = None,{comment}")
                    case "*":
                        print(f"    *{varname}: {t},{comment}")
            print(") -> SpirvInstruction:")
        print("    return SpirvInstruction(")
        print(f"        {opcode=},")
        print(f"        args=[{", ".join(usednames)}],")
        print(f'        hasresult="{hasresult}",')
        print("    )")


if __name__ == "__main__":
    main()
