# https://registry.khronos.org/SPIR-V/specs/unified1/MachineReadableGrammar.html

import sys
import json

VERSION = [1, 3]  # SPIR-V 1.3 <-> Vulkan 1.1


def parse_version(version: str) -> list[int]:
    return [int(s) for s in version.split(".")]


def main() -> None:
    """
    Convert spirv grammar json to Python file the way we like it.
    """
    fn = sys.argv[1]
    with open(fn, "rb") as f:
        data = json.load(f)

    _copyright = data.pop("copyright")
    major = data.pop("major_version")
    minor = data.pop("minor_version")
    revision = data.pop("revision")
    magic = data.pop("magic_number")
    _instruction_printing_class = data.pop("instruction_printing_class")
    instructions = data.pop("instructions")
    operand_kinds = data.pop("operand_kinds")
    assert len(data) == 0, data.keys()

    print(
        f"# automatically generated by vutur/tools/spriv_generator.py from {fn} version {major}.{minor}.{revision}, target version {VERSION[0]}.{VERSION[1]}"
    )

    print("from enum import IntFlag, Enum")
    print()
    print(f"SPIRV_MAGIC_NUMBER = {magic}")
    print()

    kind_types = {}
    for operand_kind in operand_kinds:
        category = operand_kind.pop("category")
        kind = operand_kind.pop("kind")
        enumerants = operand_kind.pop("enumerants", None)
        match category:
            case "BitEnum":
                print(f"class {kind}(IntFlag):")
                uncommented = False
                for enumerant in enumerants:
                    enumerant_ = enumerant.pop("enumerant")
                    value = enumerant.pop("value")
                    version = enumerant.pop("version", None)
                    if version is None:
                        pass
                    elif version == "None":
                        print(f"    # {enumerant_} skipped, version None")
                        continue
                    else:
                        version_l = parse_version(version)
                        if version_l > VERSION:
                            print(f"    # {enumerant_} skipped, {version=} too new")
                            continue
                    _parameters = enumerant.pop("parameters", [])
                    # lastversion = instruction.pop("lastVersion", None)
                    _capabilities = enumerant.pop("capabilities", [])
                    _extensions = enumerant.pop("extensions", [])
                    assert len(enumerant) == 0, enumerant.keys()

                    if enumerant_ == "None":
                        print(f"    # None = {value}")
                    else:
                        uncommented = True
                        print(f"    {enumerant_} = {value}")
                if not uncommented:
                    print("pass")
                print()
                kind_types[kind] = kind
            case "ValueEnum":
                print(f"class {kind}(Enum):")
                for enumerant in enumerants:
                    enumerant_ = enumerant.pop("enumerant")
                    value = enumerant.pop("value")
                    print(f"    {enumerant_} = {value}")
                print()
                kind_types[kind] = kind
            case "Id":
                _doc = operand_kind.pop("doc")
                # we don't differentiate between id's for now
                kind_types[kind] = "SpirvInstruction"
            case "Literal":
                _doc = operand_kind.pop("doc")
                match kind:
                    case (
                        "LiteralInteger"
                        | "LiteralExtInstInteger"
                        | "LiteralSpecConstantOpInteger"
                    ):
                        t = "int"
                    case "LiteralString":
                        t = "str"
                    case "LiteralFloat" | "LiteralContextDependentNumber":
                        t = "float"
                    case e:
                        assert False, e
                kind_types[kind] = t
            case "Composite":
                bases = operand_kind.pop("bases")
                ts = [kind_types[k] for k in bases]
                t = f"Tuple[{",".join(ts)}]"
                kind_types[kind] = t
            case e:
                assert False, e
        # for enumerant in enumerants:
        #     assert len(enumerant) == 0, enumerant.keys()

        assert len(operand_kind) == 0, operand_kind.keys()

    for instruction in instructions:
        opname = instruction.pop("opname")
        _class = instruction.pop("class")
        opcode = instruction.pop("opcode")
        version = instruction.pop("version")
        lastversion = instruction.pop("lastVersion", None)
        operands = instruction.pop("operands", [])
        capabilities = instruction.pop("capabilities", [])
        extensions = instruction.pop("extensions", [])
        assert len(instruction) == 0, instruction.keys()

        if version == "None":
            print(f"# skipped {opname}, version None")
            print()
            continue
        else:
            version_l = parse_version(version)
            if version_l > VERSION:
                print(f"# skipped {opname}, {version=} too new")
                print()
                continue
        if lastversion is not None:
            lastversion_l = parse_version(lastversion)
            if VERSION > lastversion_l:
                print(f"# skipped {opname}, {lastversion=} too old")
                print()
                continue

        print(f"def {opname}(")
        varnames = [
            "foo",
            "bar",
            "baz",
            "qux",
            "quux",
            "quuux",
            "quuuux",
            "quuuuux",
            "quuuuuux",
            "quuuuuuux",
            "quuuuuuuux",
            "quuuuuuuuux",
        ]
        usednames = []
        result = None
        for operand in operands:
            kind = operand.pop("kind")
            quantifier = operand.pop("quantifier", None)
            name = operand.pop("name", None)
            match kind:
                case "IdResultType":
                    varname = "rtype"
                case "IdResult":
                    result = kind_types[kind]
                    continue
                case _:
                    varname = varnames.pop(0)
                    usednames.append(varname)
            assert len(operand) == 0, operand.keys()
            t = kind_types[kind]
            match quantifier:
                case None:
                    print(
                        f"    {varname}:{t}, {f"# {name}" if name is not None else ""}"
                    )
                case "?":
                    print(
                        f"    {varname}=None : Optional[{t}], {f"# {name}" if name is not None else ""}"
                    )
                case "*":
                    print(
                        f"    *{varname}:{t}, {f"# {name}" if name is not None else ""}"
                    )
        print(") -> SpirvInstruction:")
        print("    return SpirvInstruction(")
        print(f"        {opcode=},")
        print(f"        {capabilities=},")
        print(f"        {extensions=},")
        print(f"        args=[{",".join(usednames)}]")
        print(f"        {result=},")
        print("    )")
        print()


if __name__ == "__main__":
    main()
